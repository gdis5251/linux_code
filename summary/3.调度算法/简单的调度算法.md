# 简单的调度算法:baby_chick:

### 进程调度的原理：

**需要进程调度的理由很简单，即充分利用计算机系统中的CPU资源，让计算机系统能够多快好省地完成我们让它做的各种任务。**简单点说就是狼多肉少。进程太多啦，可是我们的CPU就那么几个。只能通过进程调度来让每一个进程都得以运行。为此，可在内存中可存放数目远大于计算机系统内CPU个数的进程，让这些进程在操作系统的进程调度器的调度下，能够让进程高效（高的吞吐量–throughput）、及时（低延迟–latency）、公平（fairness）地使用CPU。为此调度器可设计不同的调度算法来选择进程，这体现了进程调度的策略，同时还需并进一步通过进程的上下文切换（context switch）来完成进程切换，这体现了进程调度的机制。总体上说，我们需要何时调度（调度的时机）、是否能够在内核执行的任意位置进行调度（调度的方式）、如果完成进程切换（上下文切换）、如果选择“合适”的进程执行（调度策略/调度算法）、如果评价选择的合理性（进程调度的指标）。了解上述细节，也就可以说是了解了进程调度。

---

### 进程调度的指标：

> 因为不是有一种调度算法的，有多种！所以每种调度算法所依据的条件就不一样。所以就有了不同的指标来供调度算法参考。

**CPU利用率**：CPU是计算机系统中的稀缺资源，所以应在有具体任务的情况下尽可能使CPU保持忙，从而使得CPU资源利用率最高。

**吞吐量**：CPU运行时的工作量大小是以每单位时间所完成的进程数目来描述的，即称为吞吐量。

**周转时间**：指从进程创建到作进程结束所经过的时间，这期间包括了由于各种因素（比如等待I/O操作完成）导致的进程阻塞，处于就绪态并在就绪队列中排队，在处理机上运行所花时间的总和。

**等待时间**：即进程在就绪队列中等待所花的时间总和。因此衡量一个调度算法的简单方法就是统计进程在就绪队列上的等待时间。

**响应时间**：指从事件（比如产生了一次时钟中断事件）产生到进程或系统作出响应所经过的时间。在交互式桌面计算机系统中，用户希望响应时间越快越好，但这常常要以牺牲吞吐量为代价。

**这些指标其实是相互有冲突的，响应时间短也就意味着在相关事件产生后，操作系统需要迅速进行进程切换，让对应的进程尽快响应产生的事件，从而导致进程调度与切换的开销增大，这会降低系统的吞吐量。**

---

### 进程调度的方式：

存在两种进程抢占处理器的调度方式：

**可抢占式（可剥夺式，preemptive）**：就绪队列中一旦有某进程的优先级高于当前正在执行的进程的优先级时，操作系统便立即进行进程调度，完成进程切换。

**不可抢占式（不可剥夺式non_preemptive）**：即使在就绪队列存在有某进程优先级高于当前正在执行的进程的优先级时，当前进程仍将占用处理机执行，直到该进程自己进入阻塞状态，或时间片用完，或在执行完系统调用后准备返回用户进程前的时刻，才重新发生调度让出处理机。

---

### 进程调度的策略/算法：

1. **先来先服务（FCFS）调度算法**：处于就绪态的进程按先后顺序链入到就绪队列中，而FCFS调度算法按就绪进程进入就绪队列的先后次序选择当前最先进入就绪队列的进程来执行，直到此进程阻塞或结束，才进行下一次的进程选择调度。**有没有感觉很像队列的做法。**FCFS调度算法采用的是不可抢占的调度方式，一旦一个进程占有处理机，就一直运行下去，直到该进程完成其工作，或因等待某一事件而不能继续执行时，才释放处理机。操作系统如果采用这种进程调度方式，则一个运行时间长且正在运行的进程会使很多晚到的且运行时间短的进程的等待时间过长。

2. **短作业优先（SJF）调度算法**：**其实目前作业的提法越来越少，我们姑且把“作业”用“进程”来替换，改称为短进程优先调度算法**，此算法选择就绪队列中确切（或估计）运行时间最短的进程进入执行。它既可采用可抢占调度方式，也可采用不可抢占调度方式。可抢占的短进程优先调度算法通常也叫做最短剩余时间优先（Shortest Remaining Time First，SRTF）调度算法。短进程优先调度算法能有效地缩短进程的平均周转时间，提高系统的吞吐量，但不利于长进程的运行。但是呢，进程的运行时间怎么获得呢？一般都是估计而来的，所以这种调度算法往往并不准确，从而导致并不一定会使真正的短进程优先。

3. **时间片轮转（RR）调度算法**：RR 调度算法与FCFS 调度算法在选择进程上类似，但在调度的时机选择上不同。**RR调度算法定义了一个的时间单元，称为时间片（或时间量）。一个时间片通常在1～100 ms之间。当正在运行的进程用完了时间片后，即使此进程还要运行，操作系统也不让它继续运行，而是从就绪队列依次选择下一个处于就绪态的进程执行，而被剥夺CPU使用的进程返回到就绪队列的末尾，等待再次被调度。**如果时间片设置的特别大，大到足以让每个进程都完成，那么这就变成了FCFS调度算法；如果时间片设置得很小，那么处理机在进程之间的进程上下文切换工作过于频繁，使得真正用于运行用户程序的时间减少。时间片可以静态设置好，也可根据系统当前负载状况和运行情况动态调整，时间片大小的动态调整需要考虑就绪态进程个数、进程上下文切换开销、系统吞吐量、系统响应时间等多方面因素。

4. **高响应比优先（Highest Response Ratio First，HRRF）调度算法**：HRRF调度算法是介于先来先服务算法与最短进程优先算法之间的一种折中算法。先来先服务算法只考虑进程的等待时间而忽视了进程的执行时间，而最短进程优先调度算法只考虑用户估计的进程的执行时间而忽视了就绪进程的等待时间。HRRF调度算法二者兼顾，既考虑进程等待时间，又考虑进程的执行时间，为此定义了响应比（Rp）这个指标：

   **Rp=（等待时间+预计执行时间）/执行时间=响应时间/执行时间**

   上个表达式假设等待时间与预计执行时间之和等于响应时间。HRRF调度算法将选择Rp最大值的进程执行，这样既照顾了短进程又不使长进程的等待时间过长，改进了调度性能。但HRRF调度算法需要每次计算各各个进程的响应比Rp，这会带来较大的时间开销（特别是在就绪进程个数多的情况下）。

5. **多级反馈队列（Multi-Level Feedback Queue）调度算法**：

   **设置多个就绪队列，并为各个队列赋予不同的优先级。第一个队列的优先级最高，第二队次之，其余队列优先级依次降低。仅当第1～i-1个队列均为空时，操作系统调度器才会调度第i个队列中的进程运行。赋予各个队列中进程执行时间片的大小也各不相同。**在优先级越高的队列中，每个进程的执行时间片就越小或越大（Linux-2.4内核就是采用这种方式）。

   当一个就绪进程需要链入就绪队列时，操作系统首先将它放入第一队列的末尾，按FCFS的原则排队等待调度。若轮到该进程执行且在一个时间片结束时尚未完成，则操作系统调度器便将该进程转入第二队列的末尾，再同样按先来先服务原则等待调度执行。如此下去，当一个长进程从第一队列降到最后一个队列后，在最后一个队列中，可使用FCFS或RR调度算法来运行处于此队列中的进程。

   如果处理机正在第i（i > 1）队列中为某进程服务时，又有新进程进入第k（k < i）的队列，则新进程将抢占正在运行进程的处理机，即由调度程序把正在执行进程放回第i队列末尾，重新将处理机分配给处于第k队列的新进程。

   从MLFQ调度算法可以看出长进程无法长期占用处理机，且系统的响应时间会缩短，吞吐量也不错（前提是没有频繁的短进程）。所以MLFQ调度算法是一种合适不同类型应用特征的综合进程调度算法。

6. **最高优先级优先调度算法**：

   **此算法就是优先级高的先执行。**一个进程的优先级可分为两种：**静态优先级和动态优先级**。

   **静态优先级是在创建进程时确定的。**一旦确定后，在整个进程运行期间不再改变。静态优先级一般由用户依据包括进程的类型、进程所使用的资源、进程的估计运行时间等因素来设置。一般而言，**若进程需要的资源越多、估计运行的时间越长，则进程的优先级越低；反之，对于I/O bounded的进程可以把优先级设置得高。**

   **动态优先级是指在进程运行过程中，根据进程执行情况的变化来调整优先级。** **动态优先级一般根据进程占有CPU时间的长短、进程等待CPU时间的长短等因素确定。占有处理器的时间越长，则优先级越低，等待时间越长，优先级越高。**那么进程调度器将根据静态优先级和动态优先级的总和现在优先级最高的就绪进程执行。

   操作系统中为了能够让每个进程都有机会运行，需要给每个进程分配一个时间片，当一个进程的时间片用完以后，操作系统的调度器就会让当前进程放弃CPU，而选择另外一个进程占用CPU执行。为了有效地支持进程调度所需的时间片，ucore设计并实现了一个timer（计时器）功能。这样，通过timer就对基于时间事件的调度机制提供了基本支持。